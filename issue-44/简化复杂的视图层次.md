### Simplify Complex View Hierarchies
### 简化复杂的视图层级

At the heart of your app is the hierarchy of views that makes up the
user interface and the visual experience of users. With feature-rich
apps, this hierarchy grows large and complex and can become a source of performance problems. The most likely symptom you will see is a generic general slowness of the app, especially when rendering complex views to the screen.  
你的app的核心是使用视图层级来创造用户界面和视觉体验。随着app的功能越来越丰富，视图层级会越来越复杂，并且成为性能问题的来源之一。最常见的表象是app卡顿，尤其是渲染复杂视图时。

Simplifying or rearranging the view hierarchy of your app can improve performance, especially on lower-end devices and earlier versions of Android. As an added benefit, your app will become easier to maintain overall.  
简化或者重新布局你的视图层级可以提升app的性能表现，尤其是在低配设备和早期的Android版本上。另外的好处是，你的app会变得更容易维护。

**Pre-work:** If you have not done so already, [reduce overdraw by
removing unnecessary
backgrounds](https://medium.com/google-developers/draw-what-you-see-and-clip-the-e11-out-of-the-rest-6df58c47873e#.d9t0874dv) to eliminate a common source of slowness that is not related to your view hierarchy.  
**准备**阅读[通过移除无用的背景减少过度绘制](https://medium.com/google-developers/draw-what-you-see-and-clip-the-e11-out-of-the-rest-6df58c47873e#.d9t0874dv)这篇文章来排除这一常见的和视图层级无关的卡顿原因，如果你还没有看过的话。

### Analyze the view hierarchy 
### 分析视图层级
Analyzing the view hierarchy is an example of using several tools
together to pinpoint and fix performance problems. So, you may need to use just one, or all of these tools to optimize performance.  
分析视图层级就是使用几个工具来定位并修复性能问题。所以，有时你只需要一个工具，有时需要全部使用来优化性能。

#### Profile GPU Rendering
#### GPU呈现模式分析

1. [**Run the Profile GPU Rendering
    tool**](http://developer.android.com/tools/performance/profile-gpu-rendering/index.html?utm_campaign=app_series_complexviewhierarchies_012616&utm_source=medium&utm_medium=blog) **and look at the BLUE segments of the bars.** If the blue segments are tall and causing the bars to cross the 16 mspf line, your app spends a lot of time updating display lists. The M release of Android adds additional color segments, and the light-green Measure/Layout segment may also be larger than expected. One reason for this can be view hierarchies that are unnecessarily complex. This only tells you there may be a problem, it doesn’t tell you, where to look. So, let’s move forward.  
1. [**运行GPU呈现模式分析工具**](http://developer.android.com/tools/performance/profile-gpu-rendering/index.html?utm_campaign=app_series_complexviewhierarchies_012616&utm_source=medium&utm_medium=blog)**并且观察柱状图蓝色的部分。** 如果蓝色的部分过高并且导致柱状图高度超过了16ms的标志线，那就是你的app花费了大量时间来更新display list。Android 6.0 增加了额外的颜色，表示Measure/Layout的浅绿色也容易超乎预期的耗时。导致这些的一个原因就是试图层级过于复杂了。当然这只能告诉你有问题，而不能告诉你问题出在哪里。让我们接着往下看。

#### Show GPU View Updates
#### 显示GPU视图更新

1. **Run the Show GPU View Updates tool** on your mobile device. In
    **Developer Options**, scroll to **Hardware accelerated rendering** and turn on **Show GPU view updates**.
2.  Interact with your app.
3.  Views on the screen that are updated will flash red. If you notice that parts of your screen are flashing, and they have nothing to do with the area that’s being updated, there may be a connection in the view hierarchy that’s causing them to be invalidated improperly. As such, you can focus your efforts on these areas to find problems faster.  
1. 在你的设备上**运行显示GPU视图更新工具**。在**开发者选项中**，找到**硬件加速渲染**然后打开**显示GPU视图更新**。
2. 操作你的app。
3. 在屏幕上的试图更新时会闪红光。如果你注意到屏幕上和正在更新的区域无关的视图闪动，那很可能是两者之间在视图层级上相关联导致了视图被不正确的失效了。这样，你就可以关注在这些区域上来更快的查找到问题。

#### Hierarchy Viewer
#### Hierarchy Viewer
This is the tool, where you’ll do the heavy lifting.

1.  **Start the** [**Hierarchy Viewer
    tool**](http://developer.android.com/tools/performance/hierarchy-viewer/index.html?utm_campaign=app_series_complexviewhierarchies_012616&utm_source=medium&utm_medium=blog)
2.  Find the areas of the view hierarchy where you still see a lot of overdraw in your app. Consider whether restructuring your views could reduce overdraw.
3.  Identify areas where your view hierarchy is complex, and consider how you could simplify it.
4. [**Profile**](https://developer.android.com/tools/performance/hierarchy-viewer/profiling.html?utm_campaign=app_series_complexviewhierarchies_012616&utm_source=medium&utm_medium=blog) the view hierarchy from Hierarchy Viewer to confirm or identify additional potential problem spots.  
1. **开启** [**Hierarchy Viewer工具**](http://developer.android.com/tools/performance/hierarchy-viewer/index.html?utm_campaign=app_series_complexviewhierarchies_012616&utm_source=medium&utm_medium=blog)。
2. 找到你app中仍然有大量过度绘制的视图层级。考虑重新调整你的视图来减少过度绘制。
3. 定位到视图层级复杂的区域，考虑如何能简化它。
4. [**分析**](https://developer.android.com/tools/performance/hierarchy-viewer/profiling.html?utm_campaign=app_series_complexviewhierarchies_012616&utm_source=medium&utm_medium=blog)视图层级中额外潜在的问题节点。

#### Deep-dive with lint
#### 使用lint深入挖掘问题

Use the [lint
tool](http://developer.android.com/tools/debugging/improving-w-lint.html?utm_campaign=app_series_complexviewhierarchies_012616&utm_source=medium&utm_medium=blog) on your layout files to search for possible view hierarchy optimizations…however, the awesomeness of lint is for another article.  
在布局文件上使用[lint](http://developer.android.com/tools/debugging/improving-w-lint.html?utm_campaign=app_series_complexviewhierarchies_012616&utm_source=medium&utm_medium=blog)来搜寻可能的视图层级上的优化。然而关于lint的好处需要另写一篇文章。

### Simplify your view hierarchy
### 简化视图层级
#### Remove views that do not contribute to the final image
#### 移除对最终图像无用的视图

To identify views that do not contribute to the final image on the
screen:  
按照如下步骤来确定对最终图像无用的视图：

1.  In Hierarchy Viewer, walk through the hierarchy starting from the leaves towards the root.
2.  Click each node to see how the screen looks at that node. Alternatively, look at the Layout View window to see how views are layering themselves.
3.  If a view that was previously visible becomes fully hidden, then you may not need that view at all, as shown in Figure 1.
4.  Eliminate from your code the views that are completely covered, never displayed, or outside the screen.  
1. 在Hierarchy Viewer中，从叶子节点像根节点查看视图层级。
2. 点击每一个节点来查看屏幕当前的图像。在Layout View窗口查看视图是如何分层的
3. 如果一个之前可见的视图被完全隐藏，那么你可能根本就不需要这个视图，如图1.
4. 在你的代码中消除被完全遮盖，从来不显示或者在屏幕区域外的视图。

![](https://cdn-images-1.medium.com/max/1600/1*QMPA7SXtteGO8N3-jL9nOg.png)

Figure 1. Views 2 and 3 are fully obscured and can be safely removed.  
图1. 视图2和3被完全遮盖可以安全的移除。

#### Flatten the view hierarchy to reduce nesting
#### 扁平化视图层级来减少嵌套
1.  Does your view hierarchy have parts that look like the nested
    arrangement on the left of Figure 2?
2.  Flatten the view hierarchy by replacing nested linear layouts with relative layouts wherever possible. See [Optimizing Layout
    Hierarchies](http://developer.android.com/training/improving-layouts/optimizing-layout.html?utm_campaign=app_series_complexviewhierarchies_012616&utm_source=medium&utm_medium=blog)  
1. 你的视图层级中有没有看起来类似图2的嵌套？
2. 当可行时，使用相对布局替代嵌套的线性布局来扁平化视图层级。查看[优化视图层级](http://developer.android.com/training/improving-layouts/optimizing-layout.html?utm_campaign=app_series_complexviewhierarchies_012616&utm_source=medium&utm_medium=blog).

![](https://cdn-images-1.medium.com/max/1600/1*jXKTaat2OOfe_yHBn97KKw.png)

Figure 2. This deep view hierarchy can be flattened to improve
performance.  
图2. 这个层次很深的视图层级可以变得扁平化来提升性能。

#### Reduce the number of views
#### 减少视图的数量

1.  If your user interface has many simple views, you may be able to combine some of them without diminishing the user experience, as shown in Figure 3.
2.  Both the changes below may affect how you present information to the user and will include design trade-offs. Remember that performance is more important than anything else for your app’s success, and opt for simplicity wherever you can.
3.  Reduce the number of views by combining them into fewer views. For example, you can combine text views if you reduce the number of fonts and styles.
4.  Redesign your app’s user interface to use fewer views.  
1. 如果你的用户界面有很多简单的视图，你可以在不影响用户体验的前提下，像图3那样结合其中的一些。
2. 所有的改变都会影响你呈现信息的方式当然包括设计上的权衡。不过要记住性能表现是你app成功与否最重要的一点，无论什么情况下，尽你可能的选择优化。
3. 合并一些视图。比如：如果你减少字体和样式，就可以合并text view。
4. 重新设计你的用户界面来使用更少的视图。

![](https://cdn-images-1.medium.com/max/1600/1*Xf91SQNrLdvp-5qAJJzpqw.png)

Figure 3. Example of combining views.
图3. 合并视图的列子

#### Simplify nested layouts that trigger multiple layout passes
#### 简化会导致多次layout的嵌套布局

Some layout containers, such a RelativeLayout, require two layout passes in order to finalize the positions of their child views. As a result, their children also require two layout passes. When you nest these types of layout containers, the number of layout passes increases exponentially with each level of the hierarchy.  
像RelativeLayout这样的父视图，需要两次layout的过程来最终确定子视图的位置。结果就是，他们的子视图也需要两次layout过程。当你再把这些父视图嵌套在一起时，layout过程的次数就会以指数级增长。

For example, a view inside a grid view inside a list view inside a
relative layout could get laid out 8 times(!) as shown in Figure 4.  
举个列子，RelativeLayout钟嵌套一个ListView，ListView中嵌套一个GridView，GridView中嵌套一个view，这会导致8倍的layout，如图4.

![](https://cdn-images-1.medium.com/max/1600/1*fSH3-AJcAHXBG0O0R_ijUQ.png)

-  [RelativeLayout](http://developer.android.com/reference/android/widget/RelativeLayout.html?utm_campaign=app_series_complexviewhierarchies_012616&utm_source=medium&utm_medium=blog)
-   [Linear
    layouts](http://developer.android.com/reference/android/widget/LinearLayout.html?utm_campaign=app_series_complexviewhierarchies_012616&utm_source=medium&utm_medium=blog) that also use *measureWithLargestChild*.
-   [Grid
    views](http://developer.android.com/reference/android/widget/GridView.html?utm_campaign=app_series_complexviewhierarchies_012616&utm_source=medium&utm_medium=blog) that also use gravity.
-   Custom containers that are subclasses of the above.
-   Some uses of weights can also trigger multiple layout passes.  
- [RelativeLayout](http://developer.android.com/reference/android/widget/RelativeLayout.html?utm_campaign=app_series_complexviewhierarchies_012616&utm_source=medium&utm_medium=blog)
- [Linearlayouts](http://developer.android.com/reference/android/widget/LinearLayout.html?utm_campaign=app_series_complexviewhierarchies_012616&utm_source=medium&utm_medium=blog)使用*measureWithLargestChild*方法
- [GridView](http://developer.android.com/reference/android/widget/GridView.html?utm_campaign=app_series_complexviewhierarchies_012616&utm_source=medium&utm_medium=blog)使用gravity
- 继承自以上容器的自定义视图
- 一些weights的使用也可以导致加倍的layout过程

Using any of these containers as the root of a complex view hierarchy, the parent of a deep subtree, or using many of them in your layout, can hurt performance. So, consider whether you can achieve the same layout using a container configuration that does not result in these exponential numbers of layout passes. For example, you could replace a relative layout with a grid view (without gravity) as your root view.  
使用任何以上的容器作为一个复杂视图的根节点，比如一个很深的子树的父节点，或者在布局中大量使用，都会影响性能。所以，多考虑如何在避免layout过程指数级增长的情况下达到相同的布局效果。比如，使用不设置gravity的gridview来替代relative layout作为根节点。