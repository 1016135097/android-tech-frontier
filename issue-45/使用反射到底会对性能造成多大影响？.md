使用反射到底会对性能造成多大影响？
---

> * 原文链接 : [How Slow is Reflection in Android?](http://blog.nimbledroid.com/2016/02/23/slow-Android-reflection.html)
* 原文作者 : [Anton Krasov](http://blog.nimbledroid.com/)
* 译文出自 : [开发技术前线 www.devtf.cn](http://www.devtf.cn)
* 转载声明: 本译文已授权[开发者头条](http://toutiao.io/download)享有独家转载权，未经允许，不得转载!
* 译者 : [chaossss](https://github.com/chaossss) 
* 校对者: [chaossss](https://github.com/chaossss)
* 状态 :  完成 



(So far we’ve analyzed a lot of apps and discovered a handful of issues that significantly slow down many apps. Starting from this post, we’ll describe these issues one by one.)

(最近我们分析了大量的应用，并发现了许多影响 App 性能的原因，从这篇博文开始，我会一个一个地介绍我们的发现)

Reflection is, of course, an extremely useful aspect of Java and Android development. Yet it turns out that reflection can very often be the source of significant slowdown within an Android application. Perhaps the most intuitive way of understanding this is going through a couple of real-life examples.

不论是 Java 开发还是 Android 开发，反射都是非常好用的工具，但反射同时也是影响 Android 应用性能的一大原因，下面就讲两个例子让大家了解反射的坏处吧：

##Two Real-world Examples
##两个真实的例子

Our first example involves NYTimes Android app. With the help of NimbleDroid, our friends at NYTimes found out that the reflective type adapters in Gson cost their Android app a 700ms startup delay. They eventually fixed this delay with manually written custom type adapters.

Our second example involves Photobucket, a large photo-sharing platform. Here, reflection again causes a big bottleneck.

第一个例子就是 NYTimes Android App 了。在 NimbleDroid 的帮助下，NYTimes 的程序猿发现 Gson 中使用的反射型 Adapter 在应用启动时增加了大约 700ms 的延迟，最终他们通过手动地适配每一种数据类型对应的 Adapter 解决了这个问题。

第二个例子就是 Photobucket，Photobucket 是一个大型的图片分享平台，而 Photobucket 的程序猿在开发时使用的反射技术也给他们带来了一些性能瓶颈。

![](http://blog.nimbledroid.com/assets/slow-android-reflection/com.photobucket.android-iricle-graph-top.png)
660ms for call com.photobucket.api.client.jersey.UserClient constructor
调用 com.photobucket.api.client.jersey.UserClient 构造器需要 660ms

We see that the com.photobucket.api.client.jersey.UserClient constructor takes an entire 660ms to run. Looking further into the icicle graph, we see that the reason for such a lag lies in reflection. Check this out:

com.photobucket.api.client.jersey.UserClient 构造器需要 660ms 才能执行完成，不妨细看该柱状图，我们会发现大部分开销都来自于反射：

![](http://blog.nimbledroid.com/assets/slow-android-reflection/com.photobucket.android-iricle-graph-bottom.png)

lots of reflection calls, like: java.lang.Class.getGenericInterfaces
构造方法中有大量的反射调用，例如：java.lang.Class.getGenericInterfaces

Note that the getGenericInterfaces() method returns the types of the interfaces that this class directly implements. Here, it is invoked 5 times and takes ~81ms. Sure, on the surface this may not seem like much, but altogether, use of the method is causing ~600ms of start time delay. Let’s take a deeper look at why this is taking so long.

需要提醒的是：getGenericInterfaces() 返回类具体实现的接口类型，在该构造方法中，它被调用了5次，大约需要81ms。81ms看起来好像不多，但所有的反射调用加起来可就差不多 600ms了，不妨看看为什么需要这么多时间。

It turns out that this library allows developers to configure a REST client with annotations. The issue is that the library doesn’t process the annotations during build time, but instead parses and creates the REST client during runtime (with the help of reflection). From a performance point of view, this is catastrophic.

从源码上看，该库似乎允许开发者通过注解配置 REST 客户端，问题就是：该库没有在编译期处理注解，而是在运行时解析和创建 REST 客户端（利用反射）。从性能的角度看，这就是灾难性的打击。

##Micro-benchmarks
##微基准

We’ve created a simple test to quantify how slow reflection is.

We will work with the android.app.Activity class and repeat operations 10,000 times, like this:

下面我们创建一个简单的例子以测试反射到底有多慢。

例子中使用的类是 Activity，然后重复执行某个操作大约10000次，具体代码如下：

```java
Class<?> clazz = android.app.Activity.class;
for (int i = 0; i < 10000; i++) {
	clazz.getFields();
}
```

We’ve also set up two tests that include creating objects (of the type DummyItem, an empty dummy class) to look at the overhead purely caused by reflection. Here’s an example:

此外，我们还有关于创建对象的测试（DummyItem 是一个空类），以了解反射创建对象的开销：

```java
try {
    for (int i = 0; i < 1_000_000; i++) {
        DummyItem.class.newInstance();
    }
} catch (InstantiationException e) {
    e.printStackTrace();
} catch (IllegalAccessException e) {
    e.printStackTrace();
}
```

And here are our results (all numbers are in ms, measured on our personal devices with real usage to make the results more faithful to real world):

下面是测试的结果（下面的数值单位都是 ms，而且都是真实设备测试的）：

||NEXUS 5 (6.0) ART|GALAXY S5 (5.0) ART|GALAXY S3 mini (4.1.2) Dalvik|
|getFields|1108|1626|27083|
|getDeclaredFields|347|951|7687|
|getGenericInterfaces|16|23|2927|
|getGenericSuperclass|247|298|665|
|makeAccessible|14|147|449|
|getObject|21|167|127|
|setObject|21|201|161|
|createDummyItems|312|358|774|
|createDummyItemsWithReflection	1332|6384|2891|

It’s evident that reflection in Android is excruciatingly slow - compare the (1332ms, 6384ms, 2891ms) with reflection to the (312ms, 358ms, 774ms) without reflection. Interestingly, Android 5.0 ART on a more powerful device actually makes reflection much slower than Android 4.1 Dalvik on a less powerful device; only in Android 6.0 ART is the overhead reduced, but the overhead is still quite significant.

很显然反射在 Android 中真的非常慢，使用反射的时间开销是(1332ms, 6384ms, 2891ms)，没使用反射的时间开销是(312ms, 358ms, 774ms)。有趣的是，Android 5.0 使用的 ART 虚拟机在更好的设备上使用反射的性能甚至比 Android 4.0 使用的 Dalvik 在更老的设备上要差。而在 Android 6.0 ART 上性能表现就好很多，但开销还是很高。

##More real-world examples
##更多的实例

ActiveAndroid is another library that uses reflection. Let’s take a look at how it can affect start time by analyzing some real apps on the Play store:

Here’s the Scribd app:

ActiveAndroid 是一个使用反射实现的库，不妨分析应用市场中使用它的应用，看看它对应用启动时间的影响：

这是 Scribd 的性能表现：

![](http://blog.nimbledroid.com/assets/slow-android-reflection/Scribd.png)

1093ms for call com.activeandroid.ActiveAndroid.initialize
com.activeandroid.ActiveAndroid.initialize 调用开销是 1093ms

Myntra sees similar problems:
Myntra 也出现了一样的问题：

![](http://blog.nimbledroid.com/assets/slow-android-reflection/Myntra.png)

1421ms for call com.activeandroid.ActiveAndroid.initialize
com.activeandroid.ActiveAndroid.initialize 调用开销是 1421ms

As you can see, the library requires more than a second to initialize. That’s a lot of time, especially taking into consideration that users expect an average app start time of 2s.

如你所见，该库需要超过1秒的时间以进行初始化，考虑到用户期待应用的启动时间的平均值为2秒，这个时间真的很多……

To conclude, reflection in Android is really slow. To guarantee you offer users the smoothest experience possible, we recommend the following:

总的来说，反射在 Android 终点性能表现真的不佳，为了尽可能给用户提供平滑的体验，我们建议：

> Recommendation: avoid using reflection (or libraries that use reflection) altogether. In particular, do not use reflective type adapters to serialize Java objects.
> 建议：避免使用反射（或者使用反射的库），特别是，别使用反射型 Adapter 去序列化 Java 对象。