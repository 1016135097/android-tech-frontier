在滚动列表中播放视频
---

> * 原文链接 : [Implementing video playback in a scrolled list (ListView & RecyclerView)](https://medium.com/@v.danylo/implementing-video-playback-in-a-scrolled-list-listview-recyclerview-d04bc2148429#.giv0pte0s)
* 原文作者 : [Danylo Volokh](https://medium.com/@v.danylo)
* 译文出自 : [开发技术前线 www.devtf.cn](http://www.devtf.cn)
* 转载声明: 本译文已授权[开发者头条](http://toutiao.io/download)享有独家转载权，未经允许，不得转载!
* 译者 : [chaossss](https://github.com/chaossss) 
* 校对者: [这里校对者的github用户名](github链接)  
* 状态 :  完成 



In this article I will describe how to implement video playback in the list. The same that works in popular applications like Facebook, Instagram or Magisto:

本篇博文将会介绍如何实现在列表中播放视频，具体效果参见：Facebook，Instagram 或 Magiston：

###Facebook:

![](https://cdn-images-2.medium.com/max/800/1*vizszEHcRhlK1MV7nrMSWw.gif)

###Magisto:

![](https://cdn-images-2.medium.com/max/800/1*9TcSE9YEENQNIcqCT7d2ww.gif)

###Instagram:

![](https://cdn-images-2.medium.com/max/800/1*3Lpr8C613ZfgazADX9eKyQ.gif)

This article is based on the opensource project: [VideoPlayerManager](https://github.com/danylovolokh/VideoPlayerManager).

博文内容基于此Github 项目：[VideoPlayerManager](https://github.com/danylovolokh/VideoPlayerManager).

All the code and a working sample is there. In this article a lot of things will be skipped, so if someone really needs to understand how it works it’s better to download the source code and read the article with the source code in your IDE. But even without the code this article will be good for understanding with what we are dealing here.

博文中涉及的所有代码和范例都在该项目中，所以本篇博文不会详细讲解每一个细节。如果有人真的想知道实现的机制，最好是下载源码，结合 IDE 边看源码边阅读本文。不过就算你不结合源码，光看我在这里说的内容，也能理解的七七八八了。

##Two Problems
##两个问题

To implement what is needed we have to solve two problems:

为了实现这个功能，我们需要解决以下两个问题：

1. We have to manage video playback. In Android we have a class MediaPlayer.class that works together with SurfaceView and can playback a video. But it has a lot of drawbacks. We cannot use usual VideoView in the list. VideoView extends SurfaceView, and SurfaceView doesn’t have UI synchronization buffers. All this will lead us to the situation where video that is playing is trying to catch up the list when you scroll it. Synchronization buffers are present in TextureView but there is no VideoView that is based on TextureView in Android SDK version 15. So we need a view that extends TextureView and works with Android MediaPlayer. Also almost all methods (prepare, start, stop etc…) from MediaPlayer are basically calling native methods that work with hardware. Hardware can be tricky and if will do any work longer than 16ms (And it sure will) then we will see a lagging list. That’s why need to call them from background thread.

1. 管理视频播放。在 Android 框架层中我们可以利用 MediaPlayer 和 SurfaceView 来播放视频，但这种实现方式有许多缺点。我们不能在列表中使用一般的 VideoView，因为 VideoView 是 SurfaceView 的子类，而 SurfaceView 不具有 UI 异步缓存。而这会导致我们无法在滚动时记录视频到底播放到哪个时间点。TextureView 具有 UI 异步缓存，但在 Android SDK 15 没有 VideoView 的实现方式是借助 TextureView 来完成的。因此，我们需要一个 TextureView 的子类与 MediaPlayer 协作完成视频播放的功能。当然了，MediaPlayer 中的所有方法（准备，开始，停止等等……）几乎都是调用与硬件交互的内核层代码。而硬件往往意味着复杂，如果我们需要完成的任何工作的耗时超过 16ms（一般都会），就会看到滞后的视频列表。这也是为什么需要在后台线程中调用它们的原因。

2. We also need to know which view on the scrolled list is currently active to switch the playback when user scrolls. So basically we have to track the scroll and define the most visible view if it changes.

2. 我们还需要知道滚动列表中的哪一个 View 要被激活（播放视频），所以我们还需要追踪用户的滚动行为并定义可见域最大的 View。

##Managing Video Playback
##管理视频播放

Here we aim to provide following functionality:

Assume that movie playback is on. User scrolls the list and new item in the list becomes more visible than the one which video is playing. So now we have to stop the existing video playback and start the new one.

The main functionality is : stop previous playback, and start the new playback only after the old one stops.

Here is a video sample of how it works: When you press on the video thumbnail — current video playback stops and the other one starts.

![](https://cdn-images-2.medium.com/max/800/1*V7cAiFeKurRMTLbZTQtLkA.gif)

##VideoPlayerView

First thing that we need to implement is the VideoView based on the TextureView. We cannot use VideoView in scrolling list. Because video rendering will be messed up if user will scroll our list during playback.

我们要做的第一件事就是以 TextureView 为父类实现 VideoView。而且我们在滚动列表中不能使用 VideoView，因为用户在视频播放的过程中滚动列表的话，视频渲染就会乱掉。

I’ve divided this task into several parts:

我把这部分工作分为几个部分：

1. Created a ScalableTextureView. It’s a descendant of TextureView and it knows how to adjust the SurfaceTexture (on this surface texture the playback is running) and provides few options similar to ImageView scaleType.

1. 创建继承于 TextureView 的 ScalableTextureView，它能够调整 SurfaceTexture（正在播放视频的表面结构中）而且提供了一些类似于 ImageView 缩放类型的选项。

```java
public enum ScaleType {
    CENTER_CROP, TOP, BOTTOM, FILL
}
```

2. Created VideoPlayerView. This is a descendant of ScalableTextureView and it contains all the functionality related to MediaPlayer.class. This custom view encapsulates MediaPlayer.class and provides an API very similar to VideoView. It has all the methods that are directly calling MediaPlayer : setDataSource, prepare, start, stop, pause, reset, release.

2. 创建 ScalableTextureView 的子类 VideoPlayerView，它包含所有与 MediaPlayer 相关的功能。即，这是一个封装了 MediaPlayer 并提供与 VideoView 几近一致的 API 的自定义 View。VideoPlayerView 具有所有直接调用 MediaPlayer 的方法：setDataSource，prepare, start, stop, pause, reset, release。

##Video Player Manager and Messages Handler Thread
##ViedioPlayer 管理器及消息控制机制

Video Playback Manager works together with the MessagesHandlerThread that is responsible for calling the methods of MediaPlayer . We need to call the methods like prepare(), start() etc. in a separate thread because they are directly connected to devices hardware. And there were cases when we called MediaPlayer.reset() in the UI thread but something went wrong with the player and this method was blocking the UI thread for almost 4 minutes! That’s why we don’t have to use asynchronous MediaPlayer.prepareAsync, we can use synchronous MediaPlayer.prepare . We are doing everything synchronously in a separate thread.

视频播放管理器与负责异步调用 MediaPlayer 方法的 MessageHandlerThread 协作。因为我们需要调用的方法，如：prepare(), start() 等等……与硬件直接相关，所以我们需要在一个独立的线程中完成这些调用。此外，当我们在 UI 线程中调用 MediaPlayer.reset() MediaPlayer 会发生一些奇怪的问题，使得该方法阻塞了将近 4 分钟！这也是我们不必须调用异步的 MediaPlayer.prepareAsync() 方法的原因，我们完全可以在另一个线程中调用 MediaPlayer.prepare() 方法，免得让这些奇怪的问题折腾自己。因此，我们将在一个独立的线程中异步完成所有任务。

A flow related to starting new playback. Here is a few steps to do with MediaPlayer:

在开始新的视频播放任务的事件流中，下面是一些与 MediaPlayer 相关的步骤：

1. Stop previous playback. It’s done by calling MediaPlayer.stop() method.

1. 停止前一个播放任务，通过调用 MediaPlayer.stop() 方法完成。

2. Reset MediaPlayer by calling MediaPlayer.reset() method. We need to do it because in scrolling list your view might be reused and we want to have all resources released.

2. 通过调用 MediaPlayer.reset 方法重置 MediaPlayer。之所以需要这样做是因为：在滚动列表中，View 可能会被重用，而我们想要释放所有的资源。

3. Release MediaPlayer by calling MediaPlayer.release() method.

3. 通过调用 MediaPlayer.release() 方法释放 MediaPlayer 占用的资源。

4. Clear the instance of MediaPlayer. New MediaPlayer instance will be created when new playback on this view should be started.

4. 清除 MediaPlayer 的实例，当 View 执行新的播放任务时，创建新的 MediaPlayer 实例。

5. Create instance on MediaPlayer for new most visible view.

5. 为新的可见域最大的 View 创建 MediaPlayer 实例。

6. Set the data source for new MediaPlayer by calling MediaPlayer.setDataSource(String url).

6. 调用 MediaPlayer.setDataSource(String url) 为新的 MediaPlayer 设置数据源。

7. Call MediaPlayer.prepare(). There is no need to use asynchronous MediaPlayer.prepareAsync().

7. 调用 MediaPlayer.prepare() 方法而不是 MediaPlayer.prepareAsync()。

8. Call MediaPlayer.start()

8. 调用 MediaPlayer.start()。

9. Wait for actual playback to start.

9. 等待播放开始。

All these actions are wrapped into Messages that are processed in a separate thread, for example this is Stop message. It calls VideoPlayerView.stop(), which eventually calls the MediaPlayer.stop(). We need custom messages because we can set current state. We know is it Stopping or Stopped or else. It helps us to control which message is now in progress and what can we do about it if we need for example, start new playback.

以上所有行为都被包裹到 Message 中，交给一个独立的线程完成，例如这是一个 Stop 命令的 Message，它将调用 VideoPlayerView.stop()，实际上他调用的是 MediaPlayer.stop()。我们需要自定义 Message，因为饿哦我们可能需要设置当前状态，例如现在是正在停止，还是已经停止，或者是其他的状态……这有助于我们了解当前处理的 Message 是什么命令，如果我们需要用这个命令的话我们可以做什么，例如，开始一个新的播放任务。

```java
/**
 * This PlayerMessage calls {@link MediaPlayer#stop()} on the instance that is used inside {@link VideoPlayerView}
 */
public class Stop extends PlayerMessage {
    public Stop(VideoPlayerView videoView, VideoPlayerManagerCallback callback) {
        super(videoView, callback);
    }

    @Override
    protected void performAction(VideoPlayerView currentPlayer) {
        currentPlayer.stop();
    }

    @Override
    protected PlayerMessageState stateBefore() {
        return PlayerMessageState.STOPPING;
    }

    @Override
    protected PlayerMessageState stateAfter() {
        return PlayerMessageState.STOPPED;
    }
}
```

If we need to start new playback we simply call a method on VideoPlayerManager. And it adds following set of messages to the MessagesHandlerThread:

如果我们需要开始一个新的播放任务，我们只需要调用 VideoPlayerManager 的一个方法，它就会添加下列 Message 到 MessagesHandlerThread 中：

```java
// pause the queue processing and check current state
// if current state is "started" then stop old playback
mPlayerHandler.addMessage(new Stop(mCurrentPlayer, this));
mPlayerHandler.addMessage(new Reset(mCurrentPlayer, this));
mPlayerHandler.addMessage(new Release(mCurrentPlayer, this));
mPlayerHandler.addMessage(new ClearPlayerInstance(mCurrentPlayer, this));
// set new video player view
mPlayerHandler.addMessage(new SetNewViewForPlayback(newVideoPlayerView, this));
// start new playback
mPlayerHandler.addMessages(Arrays.asList(
        new CreateNewPlayerInstance(videoPlayerView, this),
        new SetAssetsDataSourceMessage(videoPlayerView, assetFileDescriptor, this), // I use local file for demo
        new Prepare(videoPlayerView, this),
        new Start(videoPlayerView, this)
));
// resume queue processing
```

The messages are run synchronously that’s why we can pause the queue processing in any time and post new messages, for example:

这些 Message 都是异步处理的，因此我们能在任意时刻停止消息队列对消息的处理，并投递新的消息，例如：

Current movie is in preparing state (MedaiPlayer.prepare() was called, and MediaPlayer.start() is waiting in the queue) and user scrolled the list so we need to start playback on a new view. In this case we :

当前一个影片处于准备状态（已经调用了 MediaPlayer.prepare() 方法，而且 MediaPlayer.start() 方法正在消息队列中等待被执行），此时用户滚动了列表，所以我们需要在一个新的 View 上开始新的播放任务。在这种情况下我们会：

1. Pause queue processing

1. 停止正在执行的消息队列

2. Remove all pending messages

2. 移除所有等待执行的消息

3. Post “Stop”, “Reset”, “Release”, “Clear Player instance” to the queue. They will run right after we return from “Prepare”

3. 投递 “Stop”, “Reset”, “Release”, “Clear Player instance” 这些消息给消息队列，它们将会在 Prepare 消息回调方法执行完成后立刻被执行。

4. Post “Create new Media Player instance”, “Set Current Media Player”(this one changes the MediaPlayer object on which our messages are performed), “Set data source”, “Prepare”, “Start”. And this messages will start the playback on the new view.

4. 投递 “Create new Media Player instance”, “Set Current Media Player”（将 MediaPlayer 对象绑定到当前需要播放视频的消息上），“Set data source”, “Prepare”, “Start”等消息。这样就会在新的 View 上播放相应的视频。

OK, so we have the utilities to run the playback in the way we need: Stop previous playback and just then Start the next one.

Here is the gradle dependency for the library:

这样我们就能依照我们设想的那样执行播放任务：停止前一个播放任务，并开始新的播放任务。

下面是相关的依赖：

```
dependencies {
    compile 'com.github.danylovolokh:video-player-manager:0.2.0'
}
```

##Identifying the most visible view in the list. List Visibility Utils.
##区分列表中可见域最大的 View——列表可见域判断工具

The first problem was to manage the Video Playback. The second problem is to track which view is the most visible and switch the playback into that view.
There is an entity called ListItemsVisibilityCalculator and its implementation SingleListViewItemActiveCalculator that does all the job.

第一个问题是控制视频的播放，第二个问题则是判断哪一个 View 可见域最大，并切换该 View 对应的视频为新的播放视频。下面是调用 ListItemsVisibilityCalculator 的实体，它的具体实现 SingleListViewItemActiveCalculator 会完成对应的工作。

Your model class that is used in adapter must implement ListItem interface in order to calculate visibility of the items in the list:

在 Adapter 中被使用的 Model 类必须实现 ListItem 接口，以计算 List 中子项目的可见域：

```java
/**
 * A general interface for list items.
 * This interface is used by {@link ListItemsVisibilityCalculator}
 *
 * @author danylo.volokh
 */
public interface ListItem {
    /**
     * When this method is called, the implementation should provide a
     * visibility percents in range 0 - 100 %
     * @param view the view which visibility percent should be
     * calculated.
     * Note: visibility doesn't have to depend on the visibility of a
     * full view. 
     * It might be calculated by calculating the visibility of any
     * inner View
     *
     * @return percents of visibility
     */
    int getVisibilityPercents(View view);

    /**
     * When view visibility become bigger than "current active" view
     * visibility then the new view becomes active.
     * This method is called
     */
    void setActive(View newActiveView, int newActiveViewPosition);

    /**
     * There might be a case when not only new view becomes active,
     * but also when no view is active.
     * When view should stop being active this method is called
     */
    void deactivate(View currentView, int position);
}
```

The ListItemsVisibilityCalculator tracks the direction of scroll and calculate visibility of items in runtime. The item visibility might depend on any view inside single item in the list. It’s up to you to implement getVisibilityPercents() method.

There is a default implementation of this method in the sample demo app:

ListItemsVisibilityCalculator 将追踪滚动方向，并在运行时计算子项目的可见域。子项目的可见域依赖于列表中的任意一个咨询项目，即取决于你实现 getVisibilityPercents() 方法的方式：

```java
/**
 * This method calculates visibility percentage of currentView.
 * This method works correctly when currentView is smaller then it's enclosure.
 * @param currentView - view which visibility should be calculated
 * @return currentView visibility percents
 */
@Override
public int getVisibilityPercents(View currentView) {

    int percents = 100;

    currentView.getLocalVisibleRect(mCurrentViewRect);

    int height = currentView.getHeight();

    if(viewIsPartiallyHiddenTop()){
        // view is partially hidden behind the top edge
    percents = (height - mCurrentViewRect.top) * 100 / height;
    } else if(viewIsPartiallyHiddenBottom(height)){
        percents = mCurrentViewRect.bottom * 100 / height;
    }

    return percents;
}
```

So, each view needs to know how to calculate its visibility percents. 
SingleListViewItemActiveCalculator will be polling this value from each view when scroll is happening so the implementation should not be very heavy.

因此，每一个 View 都需要知道计算其可见域的细节。当发生滚动时，SingleListViewItemActiveCalculator 会要求每一个 View 计算其可见域大小，这也意味其开销之重。

When visibility of any neighbor item exceeds the visibility of current active item the setActive method will be called. And when it is we should switch the playback.

当任意一个子项目的可见域大小超过了当前播放视频项目的可见域大小，就会调用 setActive 方法切换播放任务。

There is also an ItemsPositionGetter that works as an adapter between ListItemsVisibilityCalculator and ListView or RecyclerView. This way ListItemsVisibilityCalculator doesn’t know if it’s ListView or RecyclerView. It just does its job. But it needs some information that is provided via ItemsPositionGetter:

下面是与 Adapter 功能类似的的 ItemsPositionGetter 的抽象逻辑，它将建立 ListItemsVisibilityCalculator 与 ListView/RecyclerView 交互的桥梁。这样的话 ListItemsVisibilityCalculator 不需要了解它需要操作的 View 到底是 ListView 还是 RecyclerView。只需要完成它自己的工作，但仍需要一些由 ItemsPositionGetter 提供的信息。

```java
/**
 * This class is an API for {@link ListItemsVisibilityCalculator}
 * Using this class is can access all the data from RecyclerView / 
 * ListView
 *
 * There is two different implementations for ListView and for 
 * RecyclerView.
 * RecyclerView introduced LayoutManager that's why some of data moved
 * there
 *
 * Created by danylo.volokh on 9/20/2015.
 */
public interface ItemsPositionGetter {
 
   View getChildAt(int position);

    int indexOfChild(View view);

    int getChildCount();

    int getLastVisiblePosition();

    int getFirstVisiblePosition();
}
```

Having that kind of logic in your model is messing up a bit with the idea of separating business logic from model. But with some modifications it might be isolated. And by the way it works fine even how it is now.

Here is the simple movie that shows how it works:

Here is a gradle dependency for the library:

这样的实现无疑会让 Model 类混入一些业务逻辑，违反了设计模式的部分原则。但通过一些简单的修改就能将它们解耦。不过现在这样它用起来也没多大的问题。

下面是预览图和依赖：

![](https://cdn-images-2.medium.com/max/800/1*Qqa81vAPYEzUWXq1dhfm6A.gif)


```
dependencies {
    compile 'com.github.danylovolokh:list-visibility-utils:0.2.0'
}
```

##Combination of Video Player Manager and List Visibility Utils to implement video playback in the scrolling list.
##组合使用上面完成的工作

Now we have two libraries that solves everything we need. Let’s combine them to get functionality we need.

Here the code from the fragment that uses RecyclerView:

现在我们需要将上面的工具库结合起来使用以完成我们的功能，下面是使用 RecyclerView 实现的代码：

1. Initialize ListItemsVisibilityCalculator, and pass a reference to a list to it.

1. 初始化 ListItemsVisibilityCalculator，并传递列表的引用

```java
/**
 * Only the one (most visible) view should be active (and playing).
 * To calculate visibility of views we use {@link SingleListViewItemActiveCalculator}
 */
private final ListItemsVisibilityCalculator mVideoVisibilityCalculator = new SingleListViewItemActiveCalculator(
new DefaultSingleItemCalculatorCallback(), mList);
```

DefaultSingleItemCalculatorCallback just calls the ListItem.setActive method when active view changes, but you can override it by yourself and do whatever you need :

当被激活（播放视频）的 View 发生改变，DefaultSingleItemCalculatorCallback 只调用 ListItem.setActive 方法，但你可以重载该方法并按照你的需求实现相应逻辑：

```java
/**
 * Methods of this callback will be called when new active item is found {@link Callback#activateNewCurrentItem(ListItem, View, int)}
 * or when there is no active item {@link Callback#deactivateCurrentItem(ListItem, View, int)} - this might happen when user scrolls really fast
 */
public interface Callback<T extends ListItem>{
    void activateNewCurrentItem(T item, View view, int position);
    void deactivateCurrentItem(T item, View view, int position);
}
```

2. Initialize VideoPlayerManager.

2. 初始化 VideoPlayerManager

```java
/**
 * Here we use {@link SingleVideoPlayerManager}, which means that only one video playback is possible.
 */
private final VideoPlayerManager<MetaData> mVideoPlayerManager = new SingleVideoPlayerManager(new PlayerItemChangeListener() {
    @Override
    public void onPlayerItemChanged(MetaData metaData) {

    }
});
```

3. Set on scroll listener to the RecyclerView and pass the scroll events to the list visibility utils.

3. 为 RecyclerView 设置滚动监听，并传递滚动事件给列表可见工具库处理。

```java
@Override
public void onScrollStateChanged(RecyclerView view, int scrollState) {
 mScrollState = scrollState;
 if(scrollState == RecyclerView.SCROLL_STATE_IDLE && mList.isEmpty()){

 mVideoVisibilityCalculator.onScrollStateIdle(
          mItemsPositionGetter,
          mLayoutManager.findFirstVisibleItemPosition(),
          mLayoutManager.findLastVisibleItemPosition());
 }
 }

@Override
public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
 if(!mList.isEmpty()){
   mVideoVisibilityCalculator.onScroll(
         mItemsPositionGetter,
         mLayoutManager.findFirstVisibleItemPosition(),
         mLayoutManager.findLastVisibleItemPosition() -
         mLayoutManager.findFirstVisibleItemPosition() + 1,
         mScrollState);
 }
}
});
```

4. Create ItemsPositionGetter.

4. 创建 ItemsPositionGetter

```java
ItemsPositionGetter mItemsPositionGetter = 
new RecyclerViewItemPositionGetter(mLayoutManager, mRecyclerView);
```

5. And we call a method in onResume to start calculating the most visible item as soon as we open the screen.

5. 在 onResume() 中调用方法以开始计算子项目的可见域，在我们显示出列表时选出可见域最大的子项目

```java
@Override
public void onResume() {
    super.onResume();
    if(!mList.isEmpty()){
        // need to call this method from list view handler in order to have filled list

        mRecyclerView.post(new Runnable() {
            @Override
            public void run() {

                mVideoVisibilityCalculator.onScrollStateIdle(
                        mItemsPositionGetter,
                        mLayoutManager.findFirstVisibleItemPosition(),
                        mLayoutManager.findLastVisibleItemPosition());

            }
        });
    }
}
```

And that’s it. We have a set of videos that are playing in the scrolled list:

然后就完成了，在滚动列表中播放许多视频：

![](https://cdn-images-2.medium.com/max/800/1*6uK9qO4g5v3DralCH03yzA.gif)

Basically this is just the explanation of most important parts. There is a lot more code in the sample app here:

这个项目关键部分的讲解基本上已经完成了，下面是具体的代码和范例：

[https://github.com/danylovolokh/VideoPlayerManager](https://github.com/danylovolokh/VideoPlayerManager)

Please see the source code for more details.

Cheers ;)

感谢阅读;)